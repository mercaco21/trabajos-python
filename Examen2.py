Examen.py
primer y segundo parcial.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17-44_u0yQAnosUTJyPamBS56SI1sKn9M
"""

#parte 1
# es una lista de diccionarios

estructura1 = [
    {"2012" : "The Artist"},
    {"2013" : "Argo"},
    {"2015" : "Birdman"},
    {"2014" : "12 Years a Slave"},
    {"2016" : "Spotlight"},
    {"2017" : "Moonlight"},
    {"2018" : "The Shape of Water"},
    {"2019" : "Green Book"},
    {"2010" : "The Hurt Locker"},
    {"2020" : "Parasite"},
    {"2011" : "The King's Speech"}
]

# hago dos clases para la lista enlazada, la cual cargo desde la estructura anterior

#parte 2
class Nodo:
    def __init__(self, clave, valor):
        self.anio = clave
        self.titulo = valor
        self.siguiente = None
class ListaEnlazada:
    def __init__(self):
        self.cabeza = None
        self.len=0
    def agregar(self, clave, valor):
        nuevo_nodo = Nodo(clave, valor)
        if self.cabeza is None:
            self.cabeza = nuevo_nodo
        else:
            nodo_actual = self.cabeza
            while nodo_actual.siguiente is not None:
                nodo_actual = nodo_actual.siguiente
            nodo_actual.siguiente = nuevo_nodo
        self.len=self.len + 1
    def imprimir_lista(self):
     actual = self.cabeza
     while actual is not None:
      print(actual.anio, end=" -> ")
      actual = actual.siguiente
     print("None")


    def eliminar(self, clave):
        nodo_actual = self.cabeza
        nodo_anterior = None
        # Buscar el nodo con la clave a eliminar
        while nodo_actual is not None and nodo_actual.anio != clave:
            nodo_anterior = nodo_actual
            nodo_actual = nodo_actual.siguiente
        # Si el nodo con la clave no se encuentra
        if nodo_actual is None:
            return False  # Nodo no encontrado
        # Si el nodo a eliminar es la cabeza
        if nodo_anterior is None:
            self.cabeza = nodo_actual.siguiente
        else:
            # Si el nodo a eliminar no es la cabeza
            nodo_anterior.siguiente = nodo_actual.siguiente
        self.len -= 1
        return True # Nodo eliminado exitosamente

    def __add__(self, other):
        if isinstance(other, ListaEnlazada):

            if self.cabeza is None:
                self.cabeza = other.cabeza
            else:
                nodo_actual = self.cabeza
                while nodo_actual.siguiente is not None:
                    nodo_actual = nodo_actual.siguiente
                nodo_actual.siguiente = other.cabeza


            self.len += other.len
        else:
            raise TypeError("Solo se puede agregar otra ListaEnlazada")

# Crear una lista enlazada y almacenar los datos de los diccionarios
lista_peliculas = ListaEnlazada()
for diccionario in estructura1:
    for clave, valor in diccionario.items():
        lista_peliculas.agregar(clave, valor)
# Ejemplo de cómo recorrer la lista enlazada
nodo_actual = lista_peliculas.cabeza
while nodo_actual is not None:
    print(f"Año: {nodo_actual.anio}, peli: {nodo_actual.titulo}")
    nodo_actual = nodo_actual.siguiente
lista_peliculas.imprimir_lista()
print(lista_peliculas.len)


print("-------------------tercera parte")
# parte 3... hacer "Otra" estructura (no utilizar la misma ordenada)  para reorganizar las pelis,
# para mayor facilidad , cuando voy encontrando el menor , lo elimino para que en la prox busqueda no esté


#parte 3
class cola_de_peliculas:
    def __init__(self):
        self.frente = None
        self.final = None
        self._tamano = 0

    def esta_vacia(self):
        return self.frente is None

    def encolar(self, clave, valor):
        nuevo_nodo = Nodo( clave, valor)
        if self.esta_vacia():
            self.frente = nuevo_nodo
            self.final = nuevo_nodo
        else:
            self.final.siguiente = nuevo_nodo
            self.final = nuevo_nodo
        self._tamano += 1


    def desencolar(self):
       """Remueve y retorna el primer elemento de la cola."""
       if self.esta_vacia():
          return None
       sacar = self.frente.data
       self.frente = self.frente.siguiente
       if not self.frente:
          self.final = None # Si la cola queda vacía, el tail también debe ser None
       self._tamano -= 1
       return sacar




    def ver_frente(self):
        if self.esta_vacia():
            return None
        return self.frente.cliente

    def tamano(self):
        return self._taman

    def imprimir_cola(self):
        actual = self.frente
        while actual is not None:
            print(f"(Año: {actual.anio}, Título: {actual.titulo})", end=" -> ")
            actual = actual.siguiente
        print("None")



def encontrar_menor_anio(lista):
  if lista.cabeza is None:
    return None
  nodo_actual = lista.cabeza
  menor_nodo = lista.cabeza
  while nodo_actual is not None:
    if int(nodo_actual.anio) < int(menor_nodo.anio):
      menor_nodo = nodo_actual
    nodo_actual = nodo_actual.siguiente

  return menor_nodo

cola1 = cola_de_peliculas()
for x in range(lista_peliculas.len):
  menor_pelicula_nodo = encontrar_menor_anio(lista_peliculas)
  lista_peliculas.eliminar(menor_pelicula_nodo.anio)
  if menor_pelicula_nodo:
     print(f"\nLa película con el menor año es: Año: {menor_pelicula_nodo.anio}, peli: {menor_pelicula_nodo.titulo}")
  else:
     print("\nLa lista de películas está vacía.")

  a=menor_pelicula_nodo.anio
  b=menor_pelicula_nodo.titulo
  print(a,b)
  cola1.encolar(a,b)

print(lista_peliculas.len)

# Imprimir la cola para verificar
print("\nCola ordenada:")
#cola1.imprimir_cola()
cola1.imprimir_cola()


# parte 4 impresiones

#parte 5
# guardar los datos de la cola_de_peliculas en una pila creada con lista enlazada

class PilaEnlazada:
    def __init__(self):
        self.cabeza = None
        self._tamano = 0

    def esta_vacia(self):
        return self.cabeza is None

    def apilar(self, clave, valor):
        nuevo_nodo = Nodo(clave, valor)
        nuevo_nodo.siguiente = self.cabeza
        self.cabeza = nuevo_nodo
        self._tamano += 1

    def desapilar(self):
        if self.esta_vacia():
            return None
        nodo_sacado = self.cabeza
        self.cabeza = self.cabeza.siguiente
        self._tamano -= 1
        return (nodo_sacado.anio, nodo_sacado.titulo)

    def ver_tope(self):
        if self.esta_vacia():
            return None
        return (self.cabeza.anio, self.cabeza.titulo)

    def tamano(self):
        return self._tamano

    def imprimir_pila(self):
        actual = self.cabeza
        while actual is not None:
            print(f"(Año: {actual.anio}, Título: {actual.titulo})", end=" -> ")
            actual = actual.siguiente
        print("None")
#(Año: 2020, Título: Parasite) -> (Año: 2019, Título: Green Book) -> (Año: 2018, Título: The Shape of Water) -> (Año: 2017, Título: Moonlight) -> (Año: 2016, Título: Spotlight) -> (Año: 2015, Título: Birdman) -> (Año: 2014, Título: 12 Years a Slave) -> (Año: 2013, Título: Argo) -> (Año: 2012, Título: The Artist) -> (Año: 2011, Título: The King's Speech) -> (Año: 2010, Título: The Hurt Locker) -> None

    def insertar_ordenado(self, clave, valor):
        nuevo_nodo = Nodo(clave, valor)
        # Si la pila está vacía o el nuevo nodo debe ser la cabeza
        if self.cabeza is None or int(self.cabeza.anio) <= int(nuevo_nodo.anio):
            nuevo_nodo.siguiente = self.cabeza
            self.cabeza = nuevo_nodo
        else:
            actual = self.cabeza
            # Encontrar el lugar correcto para insertar
            while actual.siguiente is not None and int(actual.siguiente.anio) > int(nuevo_nodo.anio):
                actual = actual.siguiente
            nuevo_nodo.siguiente = actual.siguiente
            actual.siguiente = nuevo_nodo
        self._tamano += 1




# Crear una pila enlazada
pila_peliculas = PilaEnlazada()

# Guardar los datos de la cola_de_peliculas en la pila
# Desencolamos los elementos de la cola y los apilamos en la pila
while not cola1.esta_vacia():

    if not cola1.esta_vacia():
        # Obtenemos la información del frente sin usar desencolar (para sortear el error)
        anio_a_apilar = cola1.frente.anio
        titulo_a_apilar = cola1.frente.titulo

        # Apilamos en la pila
        pila_peliculas.apilar(anio_a_apilar, titulo_a_apilar)

        # Simulamos el efecto de desencolar avanzando el frente en la cola
        # **Nota:** Esta es una solución temporal debido al error en cola1.desencolar
        cola1.frente = cola1.frente.siguiente
        if cola1.frente is None:
            cola1.final = None
        cola1._tamano -= 1
    else:
        break


print("\nPila con los datos de la cola:")
pila_peliculas.imprimir_pila()
print(f"Tamaño de la pila: {pila_peliculas.tamano()}")
print(f"Tamaño restante de la cola: {cola1._tamano}") # Debería ser 0 si el bucle terminó bien


#PARTE 6
#Por un error de carga , faltó cargar una película en los datos desde el principio, para solucionarlo,
#deberemos implementar la manera de poder ser cargada en la estructura de la parte 5,
#en forma ordenada. entonces debe  crear un método adicional a la clase que creo en ese punto (5). Volver a imprimir ahora con los datos nuevos

pila_peliculas.insertar_ordenado("2016","La pistola Desnuda")
pila_peliculas.imprimir_pila()
print(f"Tamaño de la pila: {pila_peliculas.tamano()}")




estructura2 = [
    {"2021": "Nomadland"},
    {"2022": "CODA"}
]
lista_peliculas2 = ListaEnlazada()
for diccionario in estructura2:
    for clave, valor in diccionario.items():
        lista_peliculas2.agregar(clave, valor)



#LA DEJE VACÍA ASI QUE LA VUELVO A CARGAR SOLO PORQUE ME OLVIDE DE IMPRIMIRLA
for diccionario in estructura1:
    for clave, valor in diccionario.items():
        lista_peliculas.agregar(clave, valor)
print("\nLista original antes de concatenar:")
lista_peliculas.imprimir_lista()



# 3B

#parte adicional 3B, sobrecargar + para unir sos lista
# (como su sumáramos lista 1 + lista 2), por eso se sobrecarga el operador "+"
# Concatenar lista_peliculas2 al final de lista_peliculas

lista_peliculas.__add__(lista_peliculas2)

print("\nLista original después de concatenar:")
lista_peliculas.imprimir_lista()
print(f"Tamaño de la lista original: {lista_peliculas.len}")